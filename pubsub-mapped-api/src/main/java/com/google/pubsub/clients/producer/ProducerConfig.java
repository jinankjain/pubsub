// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////

package com.google.pubsub.clients.producer;


import java.util.Map;
import java.util.HashMap;
import java.util.Properties;

import org.apache.kafka.common.config.ConfigDef;
import org.apache.kafka.common.config.AbstractConfig;
import org.apache.kafka.common.config.ConfigDef.Type;
import org.apache.kafka.common.config.ConfigDef.Range;
import org.apache.kafka.common.serialization.Serializer;
import org.apache.kafka.common.config.ConfigDef.Importance;
import org.apache.kafka.common.config.ConfigDef.ValidString;

/**
 * Provides the configurations for a KafkaProducer instance.
 */
class ProducerConfig extends AbstractConfig {

  private static final ConfigDef CONFIG;

  static final String TOPIC_CONFIG = "topic";
  private static final String TOPIC_DOC = "the topic that we will publish to.";

  static final String PROJECT_CONFIG = "project";
  private static final String PROJECT_DOC = "GCP project that we will connect to.";

  static final String KEY_SERIALIZER_CLASS_CONFIG = "key.serializer";
  private static final String KEY_SERIALIZER_CLASS_DOC = "Serializer class for key that implements"
      + " the <code>Serializer</code> interface.";

  static final String VALUE_SERIALIZER_CLASS_CONFIG = "value.serializer";
  private static final String VALUE_SERIALIZER_CLASS_DOC = "Serializer class for value that implements"
      + " the <code>Serializer</code> interface.";

  static final String BATCH_SIZE_CONFIG = "batch.size";
  private static final String BATCH_SIZE_DOC = "This configuration controls the default batch size in bytes.";

  static final String MAX_REQUEST_SIZE_CONFIG = "max.request.size";
  private static final String MAX_REQUEST_SIZE_DOC = "The maximum size of a request in bytes.";

  static final String ACKS_CONFIG = "acks";
  private static final String ACKS_DOC = "The number of acknowledgments the producer requires to consider a request complete.";

  static final String LINGER_MS_CONFIG = "linger.ms";
  private static final String LINGER_MS_DOC = "This setting adds a small amount of artificial delay."
      + "That is, rather than immediately sending out a record the producer will wait for up to "
      + "the given delay to allow other records to be sent so that the sends can be batched together.";

  static final String COMPRESSION_TYPE_CONFIG = "compression.type";
  private static final String COMPRESSION_TYPE_DOC = "The compression type for all data generated by the producer."
      + " The default is none (i.e. no compression). Right now we only support <code>gzip</code>.";

  private static final String RETRIES_CONFIG = "retries";
  private static final String RETRIES_DOC = "Setting a value greater than zero will cause the client to"
      + " resend any record whose send fails with a potentially transient error.";

  //TODO: Deal with these configs?
  /*
  public static final int DEFAULT_BUFFER_MEMORY = 32 * 1024 * 1024;

  public static final String MAX_BLOCK_MS_CONFIG = "max.block.ms";
  private static final String MAX_BLOCK_MS_DOC = "The configuration controls how long <code>KafkaProducer.send()</code> and <code>KafkaProducer.partitionsFor()</code> will block."
      + "These methods can be blocked either because the buffer is full or metadata unavailable."
      + "Blocking in the user-supplied serializers or partitioner will not be counted against this timeout.";

  public static final String BUFFER_MEMORY_CONFIG = "buffer.memory";
  private static final String BUFFER_MEMORY_DOC = "The total bytes of memory the producer can use to buffer records waiting to be sent to the server. If records are "
      + "sent faster than they can be delivered to the server the producer will block for <code>" + MAX_BLOCK_MS_CONFIG + "</code> after which it will throw an exception."
      + "<p>"
      + "This setting should correspond roughly to the total memory the producer will use, but is not a hard bound since "
      + "not all memory the producer uses is used for buffering. Some additional memory will be used for compression (if "
      + "compression is enabled) as well as for maintaining in-flight requests.";

  public static final String METRICS_NUM_SAMPLES_CONFIG = CommonClientConfigs.METRICS_NUM_SAMPLES_CONFIG;

  public static final String METRIC_REPORTER_CLASSES_CONFIG = CommonClientConfigs.METRIC_REPORTER_CLASSES_CONFIG;

  public static final String METRICS_SAMPLE_WINDOW_MS_CONFIG = CommonClientConfigs.METRICS_SAMPLE_WINDOW_MS_CONFIG;
  */

  static {
    CONFIG = new ConfigDef()
        .define(TOPIC_CONFIG, Type.STRING, Importance.HIGH, TOPIC_DOC)
        .define(PROJECT_CONFIG, Type.STRING, Importance.HIGH, PROJECT_DOC)
        .define(KEY_SERIALIZER_CLASS_CONFIG, Type.CLASS, Importance.HIGH, KEY_SERIALIZER_CLASS_DOC)
        .define(VALUE_SERIALIZER_CLASS_CONFIG, Type.CLASS, Importance.HIGH, VALUE_SERIALIZER_CLASS_DOC)
        .define(LINGER_MS_CONFIG, Type.LONG, 0, Range.atLeast(0L), Importance.MEDIUM, LINGER_MS_DOC)
        .define(BATCH_SIZE_CONFIG, Type.INT, 1, Range.atLeast(0), Importance.MEDIUM, BATCH_SIZE_DOC)
        .define(COMPRESSION_TYPE_CONFIG, Type.STRING, "none", Importance.HIGH, COMPRESSION_TYPE_DOC)
        .define(ACKS_CONFIG, Type.STRING, "1", ValidString.in("0", "1", "all"), Importance.HIGH, ACKS_DOC)
        .define(RETRIES_CONFIG, Type.INT, 0, Range.between(0, Integer.MAX_VALUE), Importance.HIGH, RETRIES_DOC)
        .define(MAX_REQUEST_SIZE_CONFIG, Type.INT, 1024 * 1024, Range.atLeast(0), Importance.MEDIUM, MAX_REQUEST_SIZE_DOC);
  }

  static Map<String, Object> addSerializerToConfig(Map<String, Object> configs,
      Serializer<?> keySerializer, Serializer<?> valueSerializer) {
    Map<String, Object> newConfigs = new HashMap<>();
    newConfigs.putAll(configs);
    if (keySerializer != null)
      newConfigs.put(KEY_SERIALIZER_CLASS_CONFIG, keySerializer.getClass());
    if (valueSerializer != null)
      newConfigs.put(VALUE_SERIALIZER_CLASS_CONFIG, valueSerializer.getClass());
    return newConfigs;
  }

  static Properties addSerializerToConfig(Properties properties,
      Serializer<?> keySerializer, Serializer<?> valueSerializer) {
    Properties newProperties = new Properties();
    newProperties.putAll(properties);
    if (keySerializer != null)
      newProperties.put(KEY_SERIALIZER_CLASS_CONFIG, keySerializer.getClass().getName());
    if (valueSerializer != null)
      newProperties.put(VALUE_SERIALIZER_CLASS_CONFIG, valueSerializer.getClass().getName());
    return newProperties;
  }

  ProducerConfig(Map<?, ?> props) {
    super(CONFIG, props);
  }
}